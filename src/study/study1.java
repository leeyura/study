package study;

public class study1 {
	public static void main(String [] args){
		// 객체생성 인스턴스화.
		A a1 = new A();
		int i = a1.b();
		
		B b1 =  new B();
	 System.out.println(b1.b());	
	}
}

class A{
	/** 오버로딩
	 * 이름이 같고 인자목록이 다른 메소드를 만드는 것
	 *  리턴유형을 다르게 만들어도되지만, 리턴유형 만 다르게 만드는 것은 오버로딩이 x
	 *  접근단계를 마음대로 지정 가능.
	 */
	void m1(int i){
		System.out.println("m1");
	}
	void m1(){
		System.out.println("m1");
	}	
	int b (){
		return 1;
	}
}

/**  상속
 * 하위 클래스가 상위 클래스의 멤버를 물려받음. 
 * 인스턴스와 메소드를 클래스 멤버라고 칭함.
 * 하위클래스에서 별도의 메소드와 인스턴스변수릉 추가할 수 있고, 
 * 만일 상위클래스의 메소드 내용을 변경하고자 할 시 상속받은 메서드를 오버라이드 할 수 있다.
 * 장점
 * 	- 코드의 중복 방지
 * - 일련의 클래스를 위한 공통적인 규약을 정리. 
 * @author lee
 *
 */

class B extends A{
	/**  오버라이딩
	 * 조상클래스로부터 상속받은 메소드의 내용을 클래스에 맞게 변경하는 것.
	 * 인자가 같아야하고, 리턴유형은 호환가능하도록 선언
	 * 접근제어자를 좁은범위로 선언할 수 없다.
	 */
	@Override
	void m1() {
		// TODO Auto-generated method stub
		super.m1();
	}
	@Override
	void m1(int i) {
		// TODO Auto-generated method stub
		super.m1();
	}
}


/**  다형성
 * 여러가지 형태를 가질 수 있는 능력
 * 하나의 참조변수로 여러 타입의 객체를 참조 할 수 있는것
 * 즉, 조상타입의 참조변수로 자손타입의 객체를 다룰 수 있는 것이 다형성.
 * 다형성을 사용하면 레퍼런스 유형을 실제 객체 유형의 상위 클래스유형으로 지정 가능.
 * 인자와 리턴 유형에도 다형성을 적용 가능.
 */
//CaptionTv c = new CaptionTv();
//Tv t =  new CaptionTv();
class Vet{
	public void getB(A a1){
		a1.b();
	}
}

/**
 * 7장 정리
 * 하위클래스는 상위클래스에 있는 모든 public 으로 지정한 인스턴스 변수와 메소드를 상속, 하지만 private으로 지정한 인스턴스의 변수와 메소드는 상속하지 않음
 * 메소드는 오버라이드 할 수 있지만 인스턴스 변수는 오버라이드 할수 없음.
 * 'A는 B다' 테스트를 활용하여 상속 계층이 올바른지 확인, X가 Y를 확장한 것이라면 'X는 Y'다 라고 할수 있어야 한다.
 * 'A는 B다' 테스트는 한 방향으로만 작동, ex.하마는 동물이다(o) 동물은 하마이다(x)
 * 하위클래스에서 메소드를 오버라이드 하면 그리고 하위클래스에서 인스턴스에 대해 그 메소드를 호출하면 오버라이드 된 버전의 메소드가 호출됨.
 * B라는클래스가 A라는 클래스를 확장 C는 B를 확장한다면  B == A == C
 */

/** 추상클래스
 * 추상메소드(미완성메서드)를 포함하고 있는 클래스
 * 일반 메소드가 추상메소드를 호출할 수 있다.
 * 완성된 클래스가 아니므로 인스턴스를 생성할 수 없다
 * 다른클래스를 작성하는데 도움을 줄 목적으로 작성된다 
 */
abstract class Player{
	int currentTime ;
	//추상클래스도 생성자가 필요.
	Player(){					
		currentTime = 0;
	}
	
	// 추상메소드
	abstract void play(int po);
	abstract void stop();
	
	void play(){
		// 추상메소드를 사용할 수 있다.
		play(currentTime);
	}
}

/** 추상메소드
 * 선언부만 있고 구현부는 없는 메소드
 * 꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우에 사용.
 * 추클래스를 상속받는 자손클래스에서 차상메서드의 구현부를 완성해야 한다.
 */
/*
 abstract class Players{
	int currentTime ;
	// 추상메소드
	abstract void play(int po1);
	abstract void stop();
	
	void play(){
		// 추상메소드를 사용할 수 있다.
		play(currentTime);
	}
}
*/
 /** object
  * 모든 클래스의 최상위 클래스.
  * object하위의 중요 메소드
  *  equals(Object o) - 두 객체를 같은 것으로 볼 수 있는지 여부
  *  getClass() - 어떤클래스의 인스턴스 인지 알수 있도록 그 객체의 클래스를 리턴
  *  hashCode() - 그 객체에 해당하는 해시코드를 출력
  *   toString() 
  */
 
/** 인터페이스
 * 일종의 추상클래스이지만 추상클래스보다 추상화 정도가높음.
 * 실제 구현된 것이 없는 기본 설계도 
 * 추상메소드와 상수만 가질 수 있다. 
 * 인스턴스를 생성할수 없고, 클래스작성에 도움을 줄 목적으로 사용
 * 미리 정해진 규칙에 따라 구현하도록 표준을 제시하는데 사용.
 */

/**
 * 클래스 ? 하위클래스 ? 추상클래스 ? 인터페이스?
 * 클래스를 새로 만드려고 할 때 그 클래스가 다른 유형에 대해서도 A는B다 테스트를 통과할 수 없다면 그냥 클래스
 * 어떤클래스의 구체적인 버전을 만들고 어떤 메소드를 오버라이드 하거나 새로운 행동을 추가해야 한다면 하위클래스
 * 일련의 하위클래스에서 사용할 틀을 구현하고 싶다면, 그리고 모든 하위 클래스에서 사용할 구현코드가 조금이라도 있다면 추상클래스,
 * 상속트리에서의 위치에 상관없이 어떤 클래스의 역할을 정의하고 싶다면 인터페이스
 */

/** 8장 정리
 * 클래스를 만들때 인스턴스를 만들수 없게 하고싶다면(그 클래스 유형의 객체를 만들수 없게 하고싶다면)abstract키워드를 사용하여 추상클래스를 생성.
 * 추상클래스에는 추상메소드와 추상메소드가 아닌 메소드 모두 넣을 수 있다.
 * 클래스에 하나라도 추상메소드가 있으면 그 클래스는 추상클래스로 지정
 * 추상메소드는 본체가 없으며 선언부분은 ; 으로 끝이 난다.(중괄호를 사용하지 않음.)
 * 자바에 있는 모든 클래스는 직접 또는 간접적으로 Object(java.lang.object)의 하위클래스
 * 메소드를 선언할 때 인자, 리턴유형을 Object로 지정가능
 * 자바는 다중상속을 허용하지 않음.
 * 인터페이스는 100%순수한 추상클래스, 인터페이스에서는 추상메소드만 정의.
 * 인터페이스 생성시 class가 아닌 interface 사용.
 * 구현하고자 할때 implements 사용.
 * 인터페이스의 모든 메소드는 자동으로 public , abstract method가 되기 때문에 인터페이스를 구현하는 클래스에서는 인터페이스에 있는 모든 메소드를 구현
 * 하위클래스에서 어떠한 메소드를 오버라이드 하였을때, 상위 클래스 버전을 호출하고자 한다면, super.메소드명() 사용.
 */

/** 스택 & 힙
 * 자바를 사용할때의 두가지 메모리 공간.스택, 힙.
 * 스택 = 지역변수, 메소드 호출
 * 힙 = 모든 객체, 인스턴스변수
 */

// interface 예제.

/** 9장 정리
 * 자바에서 메모리 공간중 스택과 힙이 존재
 * 클래스 안에서 하지만 메소드 밖에서 선언된 변수가 인스턴스 변수
 * 메소드 안에서 선언된 변수 또는 매개변수가 지역변수
 * 모든 지역변수는 스택에 들어있으며 그 변소를 선언한 메소드에 해당하는 프레임 안에 들어있음.
 * 객체 레퍼런스변수도 원시변수와 마찬가지로 지역변수로 선언했으면 스택에 저장
 * 레퍼런스가 지역변수든 인스턴스 변수든 상관없이 모든 객체은 힙에 저장.
 * 생성자 - 어떤 클래스 유형에 대해 new키워드를 사용할때 실행되는 코드 
 * 생성자 명은 반드시 클래스명과 같아야하며, 리턴유형은 없어야함.
 * 생성자를 이용하여 생성되는 객체의 상태(인스턴스변수)를 초기화 할 수 있음.
 * 클래스에 생성자가 없으면 컴파일러에서 기본 생성자(인자가 없는)를 만듬.
 * 클래스를 만들때,, 생성자를 만들면 컴파일러에서 어떠한 기본 생성자도 생성하지 않음.
 */